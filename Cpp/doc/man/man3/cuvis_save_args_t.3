.TH "cuvis_save_args_t" 3 "Thu Jun 22 2023" "Version 3.2.0" "CUVIS C++ SDK" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cuvis_save_args_t \- options for saving as cu3/cu3s files  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <cuvis\&.h>\fP
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBCUVIS_INT\fP \fBallow_fragmentation\fP"
.br
.RI "allow to split file to multiple files\&. "
.ti -1c
.RI "\fBCUVIS_INT\fP \fBallow_overwrite\fP"
.br
.RI "allow to overwrite an existing file\&. "
.ti -1c
.RI "\fBCUVIS_INT\fP \fBallow_drop\fP"
.br
.RI "allow to drop files, if output buffers are full "
.ti -1c
.RI "\fBCUVIS_INT\fP \fBallow_session_file\fP"
.br
.RI "save files of same session number to a single cu3s file\&. "
.ti -1c
.RI "\fBCUVIS_INT\fP \fBallow_info_file\fP"
.br
.RI "save additional info file\&. "
.ti -1c
.RI "\fBCUVIS_OPERATION_MODE\fP \fBoperation_mode\fP"
.br
.RI "give the current operation mode\&. "
.ti -1c
.RI "double \fBfps\fP"
.br
.RI "the fps used in operation_mode video "
.ti -1c
.RI "\fBCUVIS_INT\fP \fBsoft_limit\fP"
.br
.RI "Out-of-order frames are sorted within the cache, as long as the cache useage is below this limit\&. "
.ti -1c
.RI "\fBCUVIS_INT\fP \fBhard_limit\fP"
.br
.RI "Maximum number of elements in output cache\&. "
.ti -1c
.RI "\fBCUVIS_INT\fP \fBmax_buftime\fP"
.br
.RI "Any frame is forced to be written after this time (in ms), latest\&. "
.in -1c
.SH "Detailed Description"
.PP 
options for saving as cu3/cu3s files 

The cube exporter works asynchronically\&. For
.SS "offline saving to session file"
When processing sesion files (\fBallow_session_file\fP=true) offline, the option \fBallow_drop\fP should be set to false\&. In this case measurements are added to the internal buffer until the size given by \fBhard_limit\fP is reached\&. 
.br
 In this mode, the options \fBsoft_limit\fP and \fBmax_buftime\fP are ignroed\&.
.SS "online saving to session file"
When recording sesion files (\fBallow_session_file\fP=true) live, the options \fBallow_drop\fP should be set to true\&.
.PP
When a new measurement is added to the cube exporter, the following strategy is applied:
.PP
.IP "1." 4
The internal buffer has a total limit of size \fBhard_limit\fP\&. If the buffer is full, it will be dropped (end)\&.
.IP "2." 4
If the buffer is not full, the \fBsoft_limit\fP is checed\&. If it is reachd, the ordering of the frame numbers is ignored and the measurement with the lowest sequence nubmer is stored to the disk directly\&. (This can mess up the order of the frames set \fBsoft_limit\fP = \fBhard_limit\fP to disable this behaviour)
.IP "3." 4
All meausurements in the internal buffer are checked: If they are held in the buffer for longer then the time given by \fBmax_buftime\fP, they are saved to disk directly\&. (This can mess up the order of the frames set \fBmax_buftime\fP to a higher value allow for longer hold time intervals\&.) 
.PP

.SH "Member Data Documentation"
.PP 
.SS "\fBCUVIS_INT\fP cuvis_save_args_t::allow_drop"

.PP
allow to drop files, if output buffers are full This options controlls the export behaviour\&. If internal write buffers are full, new measurements are either dropped or kept\&.
.PP
The policy to drop measurements on full buffer (allow_drop=true) is recommended for online opration\&. The idea is to rather drop measurements and thus allow the acquisition to continue without slowing down\&. When this policy is set, the \fBsoft_limit\fP and the \fBmax_buftime\fP options are also used (see there)\&.
.PP
If new measurements are forced to be kept (allow_drop=true), the exporter will wait until the measurement can be written\&. This polocy is recommended for batch-processing measurements (offline)\&. The options \fBsoft_limit\fP and \fBmax_buftime\fP are ignored\&.
.PP
\fBNote\fP
.RS 4
This option only applies, if \fBallow_session_file\fP=true\&. 
.RE
.PP

.SS "\fBCUVIS_INT\fP cuvis_save_args_t::allow_fragmentation"

.PP
allow to split file to multiple files\&. When exporting to a cu3s file (\fBallow_session_file\fP=true) the allow_fragmentation flag controlles if all measurements (of the same session name) are written to one file like a single file (set to false) or if each measurement is saved to a separate cu3s file (set to true)\&. The latter option generates substantial overhead\&.
.PP
When exporting to a (legacy) cu3 file (\fBallow_session_file\fP=false), the fragmentation flag will lead to multiple files exported: a <name>\&.cu3 file, followed by <name>_<postfix>\&.tiff files\&. These come as a tuple and must be kept together, else the file will be corrupted\&. This export option is intended for legacy programs that were deisnged to read raw data with the previous software verison 2\&.x\&. 
.SS "\fBCUVIS_INT\fP cuvis_save_args_t::allow_info_file"

.PP
save additional info file\&. The info file is written to the same path as the export files\&. It is a plain text file and consits of the a header showing the recoridng FPS and mode and a body, where each frame number from 0 till the last frame written is shown by their name\&. Missing frames are noted as 'dropped'\&.
.PP
\fBNote\fP
.RS 4
The output of this file is not flushed until the exporter writes to a different file or is closed\&. Thus, it is not suited to be used as a way to monitor frame drops during live acquisiton\&.
.RE
.PP
This option is ignored, when \fBallow_session_file\fP is set to false\&. 
.SS "\fBCUVIS_INT\fP cuvis_save_args_t::allow_overwrite"

.PP
allow to overwrite an existing file\&. 
.br
.PP
This option anables to allow to ovewrite files on the disk, if they exist\&.
.PP
\fBNote\fP
.RS 4
When exporting to legacy format of version 2\&.x (\fBallow_session_file\fP=false and \fBallow_fragmentation\fP=true), only the existance of the *\&.cu3 file is checked, existing *\&.tiff files are neither cleaned up nor checked if they exist prior overwriting\&. 
.RE
.PP

.SS "\fBCUVIS_INT\fP cuvis_save_args_t::allow_session_file"

.PP
save files of same session number to a single cu3s file\&. If \fBallow_fragmentation\fP is set, cu3s fill be split by measurement\&. Default in Wrappers: True 
.SS "double cuvis_save_args_t::fps"

.PP
the fps used in operation_mode video only used if \fBallow_session\fP=true and @operation_mode=Internal\&. 
.SS "\fBCUVIS_INT\fP cuvis_save_args_t::hard_limit"

.PP
Maximum number of elements in output cache\&. The hard limit is only used if \fBallow_session_file\fP=true\&.
.PP
The output cache has a maximum size of \fBhard_limit\fP\&. If more measurements are added, adding another measurment is not possible\&. Adding a measurement will lock the calling function if \fBallow_drop\fP is set to false\&. If \fBallow_drop\fP is set to true, the added frame is directrly dropped and not stored\&.
.PP
\fBNote\fP
.RS 4
This behaviour also applies when using the exproter within a worker\&. 
.RE
.PP

.SS "\fBCUVIS_INT\fP cuvis_save_args_t::max_buftime"

.PP
Any frame is forced to be written after this time (in ms), latest\&. The maximum buffer time option is only used if \fBallow_drop\fP=true and \fBallow_session_file\fP=true\&.
.PP
The time a buffer is held in the exporter's cache is tracked\&. If the time given by the max_buftime is exceeded, a measuremnt is written to disk\&.
.PP
This option also helps to guarantee a measurements to be serialized to a permanent storage and avoid data loss upon power or abnormal program termination\&.
.PP
This option will overwrite the \fBsoft_limit\fP for this frame, if needed\&. 
.SS "\fBCUVIS_OPERATION_MODE\fP cuvis_save_args_t::operation_mode"

.PP
give the current operation mode\&. Save the operation mode used while recording\&. Only used if \fBallow_session\fP is set\&. 
.SS "\fBCUVIS_INT\fP cuvis_save_args_t::soft_limit"

.PP
Out-of-order frames are sorted within the cache, as long as the cache useage is below this limit\&. The soft limit is only used if \fBallow_drop\fP=true and \fBallow_session_file\fP=true\&.
.PP
The internal chache may hold up to \fBsoft_limit\fP number of frames that are out of sequence\&.
.PP
For example: Let the the seqence number of the measurement written last be #14, and let the internal cache hold the frames #16,#17,\&.\&.\&.#24 (9 images in chache) and let the soft limit be 10 If we assume the next frame to be #25, the 10 images in cache reached the soft limit, forcing the first frame with the lowest nubmer (#16) to be written (#15 is makred as 'dropped')\&. If the next image actually is #15, this image is then written out of sequence, resulting in the order #14, #16, #15\&.
.PP
Theese are the states of the example avove\&.
.PP
.RS 4
write to disk: #14 
.RE
.PP
.RS 4
cache: #16,#17,\&.\&.\&.#24 [soft limit: 10] 
.RE
.PP
.RS 4
insert: #25 
.RE
.PP
.RS 4
write to disk: #16 
.RE
.PP
.RS 4
cache: #17,\&.\&.\&.#24, #25 [soft limit: 10] 
.RE
.PP
.RS 4
insert: #15 
.RE
.PP
.RS 4
write to disk: #15 
.RE
.PP
.RS 4
cache: #17,\&.\&.\&.#24, #25 [soft limit: 10] 
.RE
.PP
This behaviour is a compromise between keeping the seuqence in order and at the same time not storing too many images if a frame was acutally dropped\&. Increase the soft_limit to a value same or grater the \fBhard_limit\fP to disable this behaviour\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for CUVIS C++ SDK from the source code\&.
